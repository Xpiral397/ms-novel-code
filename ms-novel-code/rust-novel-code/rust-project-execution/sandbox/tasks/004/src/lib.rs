//! # Perfect‑Play Tic‑Tac‑Toe

//! The decision table is embedded at **compile time** by `build.rs`.

//!

//! Public API highlights

//! ```rust

//! use task_ws::{Board,Cell,Game};

//! let g = Game::new();

//! let next = g.best_move();            // engine suggestion

//! ```



use std::fmt::{self,Display};



#[derive(Clone,Copy,PartialEq)]

pub enum Cell { E=0, X=1, O=2 }



impl Display for Cell{

    fn fmt(&self,f:&mut fmt::Formatter<'_>)->fmt::Result{

        write!(f,"{}",match self{Cell::E=>' ',Cell::X=>'X',Cell::O=>'O'})

    }

}



#[derive(Clone)]

pub struct Board([Cell;9]);



impl Default for Board { fn default()->Self{ Self([Cell::E;9]) }}



impl Board{

    pub fn id(&self)->usize{

        const POW3:[usize;10]=[1,3,9,27,81,243,729,2187,6561,19683];

        self.0.iter().enumerate().map(|(i,c)| *c as usize * POW3[i]).sum()

    }

    pub fn turn(&self)->Cell{

        let xs=self.0.iter().filter(|&&c|c==Cell::X).count();

        let os=self.0.iter().filter(|&&c|c==Cell::O).count();

        if xs==os {Cell::X} else {Cell::O}

    }

    pub fn play(&mut self, idx:usize){

        assert!(self.0[idx]==Cell::E,"square occupied");

        self.0[idx]=self.turn();

    }

}



impl Display for Board{

    fn fmt(&self,f:&mut fmt::Formatter<'_>)->fmt::Result{

        for r in 0..3{

            if r>0 { writeln!(f,"\n—+—+—")?; }

            for c in 0..3{

                if c>0 {write!(f,"|")?;}

                write!(f,"{}",self.0[r*3+c])?;

            }

        }

        Ok(())

    }

}



/* tables generated by build.rs */

include!(concat!(env!("OUT_DIR"),"/tictac_tables.rs"));



pub struct Game{ board:Board }

impl Game{

    pub fn new()->Self{ Self{board:Board::default()} }

    pub fn board(&self)->&Board{ &self.board }

    pub fn best_move(&self)->Option<usize>{

        let id=self.board.id();

        let m = BEST[id] as usize;

        if m==255 {None} else {Some(m)}

    }

    pub fn score(&self)->i8{ SCORE[self.board.id()] }

    pub fn play_best(&mut self){

        if let Some(m)=self.best_move(){ self.board.play(m); }

    }

}



/* -------------- unit tests ----------------------------------------- */

#[cfg(test)]

mod unit{

    use super::*;

    #[test]

    fn opening_move_is_center(){

        let g = Game::new();

        assert_eq!(g.best_move(),Some(4)); // index 4 = center

    }

    #[test]

    fn perfect_game_draw(){

        let mut g=Game::new();

        while g.best_move().is_some(){ g.play_best(); }

        assert_eq!(g.score(),0); // draw

    }

}
